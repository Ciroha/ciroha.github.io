---
title: 硬件算数算法硬件设计
date: 2024-10-17
summary: 学习硬件算数算法的硬件设计方法
category: 数字IC
tags: [数字IC]
comments: true
---

> 参考书籍：Computer-Arithmetic-Algorithms-and-Hardware-Designs-2nd-Edition

# 1、硬件加法基本原理

## 1.1、基础——半加器、全加器与行波进位加法器

单bit的半加器（half-adders）与全加器（full-adders）是用于合成加法器和其他算数电路的基本构建模块。一个HA接受两个输入分别是x和y，输出一个和s和一个进位c。

![](../../assets/images/硬件算数算法设计/1.png)

HA的门级实现如上图所示，有三种不同的实现方法。

与HA不同的是，单bit的FA接受三个输入，分别是输入x和y以及上一级的进位c<sub>in</sub>，输出是和s与进位c<sub>out</sub>。一个FA可以通过使用两个HAs和一个OR门实现，示意图如下：

![](../../assets/images/硬件算数算法设计/2.png)

在常规的运算中，通常不会只对单bit的值进行计算，因此，我们需要拓展FA以完成对多bit数的加法计算，最常见的拓展是行波进位加法器，即把上一个全加器的输出进位位c<sub>out</sub>连接到下一个全加器的输入进位位c<sub>in</sub>，这样就形成了一个最基础的行波进位加法器。

![](../../assets/images/硬件算数算法设计/3.png)

## 1.2、Carry-Lookahead Adders

相较于行波进位加法器，可以优化时序路径。

待补充……

## 1.3、多操作数加法

在上面两节，我们讨论了两个操作数的加法，即`s=x+y`，但在实现乘法器或各种算法时，加法的输入操作数通常不只有2个，这种情况下，如果仍然使用行波加法器，会需要很多次加法逻辑，使得计算变得缓慢。

为了获得更快的速度，可以使用双操作数加法器的树形结构如下所示：

![](../../assets/images/硬件算数算法设计/4.png)

这样的一个二进制加法器树需要n-1个加法器。尽管这看着很奇怪，但是在上图中的Adder部分使用简单且缓慢的行波进位加法器是最好的选择，其结构如下所示：

![](../../assets/images/硬件算数算法设计/5.png)

## 1.4、Carry-save Adder

我们可以将一行二进制FAs看作是将三个加数减少为两个加数的一种方式，这种情况下，FA就变成了保存进位加法器即CSA。

![](../../assets/images/硬件算数算法设计/6.png)

CSA其实就是FA的另一种叫法，CSA的计算与FA的计算如下：

![](../../assets/images/硬件算数算法设计/7.png)

上方所示的即是FA的计算过程，采用了行波进位加法器的计算方式，同时计算两个加数和一个进位位。下方所示的CSA的计算过程，即3-2压缩器，顾名思义，将三个加数转化为了两个输出，上面一行点是当前CSA的输出值，下面一行是CSA的进位值。

同样，为了适应多操作数的计算，可以用加法器树的方式将几个CSAs连接在一起，以完成将数个加法数最终压缩为两个加法数：

![](../../assets/images/硬件算数算法设计/8.png)

上图所示的CSA树将7个k-bit的操作数减少到了2个(k+2)bit的操作数且结果相同，这样的树形结构被称为7输入的华莱士树。由此，可以进一步的引申为：

**一个**`**n**`**输入通道的华莱士树可以将其**`**k-bit**`**的输入减少为2个**`**(k+log**<sub>**2**</sub>**n-1)-bit**`**的输出。**

![](../../assets/images/硬件算数算法设计/9.png)

华莱士树的算法如上所示，一共需要一个7-bit的加法器，28个FAs和一个HA。因为每个CSA将操作数的数量减少了1.5倍，所以一个n-input的华莱士树所需要的最小层数为：

$ h(n)=1+h(2n/3) $

另一种查看数量和树高之间的关系是找到可以被h-level树减少到2个操作数的输入的数量`n(h)`：

$ n(h)= \lfloor 3n(h-1)/2 \rfloor $

h-level树的操作数最大输入数n为：

![](../../assets/images/硬件算数算法设计/10.png)

当层数为3时，所需要的操作数最多为6个，而wallace树将其化为了5个，而高速加法器的延迟通常不是一个关于位宽平滑增长的函数，例如11bits到32bits的CLA可能有相同的延迟。所以没有必要将操作数的数量化简的小于下一层的最大值，只需要用最少的FA和HA化简使得其值等于最大值即可。基于这种思想，Dadda改进了wallce树：

![](../../assets/images/硬件算数算法设计/11.png)

由于在最后使用的加法器是CPA加法器，因此，在加法器的最后一位可以有一个进位位，为了对该加法器进行最大化的利用，可以将上面几层树结构中的FA改成HA，这样就会在最后一层留下一个进位位数，其算法原理如下所示：

![](../../assets/images/硬件算数算法设计/12.png)

这就是改进后的Dadda树加法器。

# 2、硬件乘法基本原理

## 2.1、无符号数乘法

假设a为被乘数，x为乘数，p为乘积：

![](../../assets/images/硬件算数算法设计/13.png)

![](../../assets/images/硬件算数算法设计/14.png)

上图所展示的是两个4bit无符号数用点来表示的乘法过程。因为x<sub>0</sub>的值只能是0或者1，所以部分积x<sub>j</sub>a的值只能是0或者a，由此，二进制乘法就会被转化为一组数字（0或a）的移位加法。

在硬件上所对应的有两个算法，分别是右移算法和左移算法。右移算法即从最低位算起，先将部分积左移k位，再依次进行右移操作并累加。左移算法即从最高位算起，先算部分积x<sub>3</sub>a的值，再左移一位，接着加上部分积x<sub>2</sub>a的值，依次类推，算法的示意图如下：

![](../../assets/images/硬件算数算法设计/15.png)

为了在硬件中实现以上算法，需要用到加法器、移位器和选择器，左移和右移的硬件设计分别如下所示：

![](../../assets/images/硬件算数算法设计/16.png)

需要注意的是，无论是在右移或是左移中，Multilplier和Partial product共享了部分积寄存器。因为在右移/左移算法中，部分积的低/高k位暂时用不到，处于空闲状态，因此可以被Multiplier利用。其中Multiplier占据了寄存器的低/高k位并随着计算进行位移，不会对结果造成影响，可以参照算法示意图进行比对。由此，根据图示，可以直接将部分积的最低位/最高位作为选择器Mux的控制信号。

## 2.2、有符号乘法

前面讨论的都是无符号乘法，而由于加入了有符号数的计算，因此有符号乘法需要考虑的方面更多。

计算有符号数乘法的一种方法是先计算符号位、再使用无符号乘法计算无符号的数值，最后再计算出结果。但由于各种限制，这种方法一般只适用于反码的计算，不适合补码的计算，由此，接下来会讨论补码乘法的计算。

根据计算的方法，可以将补码的乘法分为两种，一种是乘数为正数，另一种是乘数为负数。

当乘数为正数时，计算的过程可以直接套用无符号乘法的计算过程：

![](../../assets/images/硬件算数算法设计/17.png)

当乘数为负数时，由于最高位代表了负数的权重，因此可以在上述基础上，在最后一个周期减去x<sub>k-1</sub>a而不是加，其算法过程如下所示：

![](../../assets/images/硬件算数算法设计/18.png)

根据以上算法，可以得到硬件实现如下所示，该硬件乘法与无符号的乘法器基本上相同：

![](../../assets/images/硬件算数算法设计/19.png)

注意到该硬件乘法器在右下角处添加了一个信号，只在乘数为负数的最后一个周期为一，为加法器Adder提供进位并控制多路选择器Mux选择被乘数的值。也就是加上了x<sub>k-1</sub>a的补码（按位取反，末位加一）。

## 2.3、Booth编码

处理补码数的另一种方法是使用**Booth编码**来表示乘数x的有符号形式。

Booth编码最初被提出是为了加速早期计算机中的radix-2乘法。在乘法器中，单独的移位比加法后移位要快，也就代表着：乘数中的1越多，乘法的速度越慢。Booth编码此时就可以很好的解决这个问题。基2Booth乘法器的数学推导可以看这篇文章（[【HDL系列】乘法器(5)——Radix-2 Booth乘法器 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/136087729)），这里不做过多介绍。

![](../../assets/images/硬件算数算法设计/20.png)

基2Booth编码表如上所示。从编码表可以看出Booth编码主要是处理连续的1，当输入序列为`0111110`时，经Booth编码可得`10000-10`，可以看到，1的数量经Booth编码后显著减少。

以下是Booth编码的乘法算数过程：

![](../../assets/images/硬件算数算法设计/21.png)

与上述相反，当输入为`10101`时，Booth编码得到的结果比原来更加复杂，似乎违背了原始的初衷，这是因为radix-2 Booth编码不能很好的解决连续的10变换。

因此radix-2 Booth编码很少用于乘法器的实现中，乘法器的实现一般会选择radix-4 Booth编码版本。

## 2.4、快速乘法器设计

快速乘法器的设计目前主要有两个方面：

1. 减少需要被加的操作数（利用编码减少1的个数）。
2. 增加加法的速度

# 3、High-Radix Multipliers

radix=2^每个周期处理的位数

![](https://cdn.nlark.com/yuque/0/2024/png/29081281/1729090848105-5df10007-8266-4d66-8ee3-ad31c76fb1a6.png)

基4Booth码的意义，将3a这种不太好直接计算的乘数替换为±a，±2a这种可以用移位计算获得的乘数。
